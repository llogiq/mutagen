# Test Plan

`mutagen`'s logic is tested using unit tests and integration tests. The integration tests need a

## Unit tests of mutators

The behavior of all mutators is tested using traditional unit tests in the corresponding modules. The mutators are run with run-time configurations constructed by the test itself.

## Tests of `#[mutate]`

The behavior of the `#[mutate]` attribute for single transformers is tested along the unit tests in each mutator.

### Test Isolation

Instead of having a program-wide unique id per mutation, each function can have their own local mutation ids by writing adding `conf(local)` to the arguments of `#[mutate]`. This ensures that each test is independent from others. Moreover, only one transformer is enabled in each test by adding `only(...)` to the mutagen arguments.

### Exhaustive Testing

Each test sets the global `mutation_id` for the single test run and runs test code. This enables exhaustive testing of all mutations within a single run of the test suite and without dependency on external environment variables.

For every mutator, it is tested whether all its mutations actually produce the expected deviation from standard behavior and that they have no effect on the code unless activated.

### Implementation Details

The code generated by `#[mutate]` references the mutators by absolute path import. (i.e. `::mutagen::..`). It is necessary to add mutagen as a dev-dependency of itself. This ensures that the path `::mutagen::...` is valid during tests, which is generated

The setting of the `mutation_id` during test is possible via special functions that mutate the global run-time configuration and are only available when enabling the feature `self_test` of `mutagen`. The feature `self_test` is not supposed to be used by users of `mutagen`.

The feature `self_test` is necessary and the `#[cfg(feature="self_test")]` cannot be replaced by `#[cfg(test)]`, since the version of mutagen that is included as a dev-dependency id not compiled in `test` mode.

The current approach *works*, but is quite hacky. If you come up with a nicer solution that implements the points mentioned in exhaustive testing and test isolation above, a PR is welcome.

## Example

Typically, a complete test of some feature looks like this
```rust
mod test_x {
    // only enable mutator `xyz`
    #[mutate(conf(local), only(xzy))]
    pub fn x() {
        // function to mutate
    }

    #[test]
    pub fn x_inactive() {
        test_with_mutation_id(0, || {
            // test and assert on `x()` where no mutations have been performed
        })
    }
    #[test]
    pub fn x_active() {
        test_with_mutation_id(1, || {
            // test and assert that the correct mutation has been performed in `x()`
        })
    }

    // more tests with other mutation ids, if more than one mutation has been performed
}
```
